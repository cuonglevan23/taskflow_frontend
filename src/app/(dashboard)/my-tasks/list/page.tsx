"use client";

import React, { useState, useCallback, useMemo } from "react";
import { BucketTaskList, TaskListItem, TaskActionTime, type TaskBucket } from "@/components/TaskList";
import { TaskDetailPanel } from "@/components/TaskDetailPanel";
import { useMyTasksSummaryData } from "@/hooks/tasks/useTasksData";
import { useUpdateTask, useCreateTask, useDeleteTask, useTaskStatusUpdate } from "@/hooks/tasks/useTaskMutations";
import { useTasksContext, type Task } from "@/contexts";
import { useTaskActionTime } from "@/hooks/tasks/useTaskActionTime";
import { useNotifications } from "@/contexts/NotificationContext";

interface MyTaskListPageProps {
  searchValue?: string;
}

const MyTaskListPage = ({ searchValue = "" }: MyTaskListPageProps) => {
  // Local state
  const [searchInput, setSearchInput] = useState(searchValue);
  const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);
  
  // Get UI state from context
  const { activeFilters } = useTasksContext();
  
  // Get notification actions
  const { actions: notificationActions } = useNotifications();
  
  // Use modern SWR hooks for data fetching - with error handling
  const {
    tasks,
    isLoading,
    error,
    revalidate
  } = useMyTasksSummaryData({
    page: 0,
    size: 1000,
    sortBy: 'startDate',
    sortDir: 'desc'
  });

  // Don't render if there's a 401 error to prevent infinite loops
  if (error && (error.status === 401 || error.message?.includes('401'))) {
    return null;
  }

  // Clean SWR action hooks
  const { updateTask, isUpdating } = useUpdateTask();
  const { createTask, isCreating } = useCreateTask();
  const { deleteTask, isDeleting } = useDeleteTask();
  const { updateStatus, isUpdating: isStatusUpdating } = useTaskStatusUpdate();

  // Action time management hook
  const { moveTaskToActionTime } = useTaskActionTime();

  // Helper function for notifications
  const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
    notificationActions.addNotification({
      title: type === 'success' ? 'Success' : 'Error',
      message,
      type: type === 'success' ? 'success' : 'error',
      priority: 'medium',
      status: 'unread',
      isRead: false,
      isBookmarked: false,
      isArchived: false,
    });
  }, [notificationActions]);

  // CRUD Handlers - All API logic handled at page level for better inheritance
  const handleTaskClick = useCallback((task: TaskListItem) => {
    setSelectedTaskId(task.id);
    setIsPanelOpen(true);
  }, []);

  const handleTaskCreate = useCallback(async (taskData: {
    name: string;
    description?: string;
    status?: string;
    priority?: string;
    startDate?: string;
    deadline?: string;
    actionTime?: string;
  }) => {
    try {
      await createTask({
        title: taskData.name,
        description: taskData.description || '',
        status: taskData.status || 'TODO',
        priority: taskData.priority || 'MEDIUM',
        startDate: taskData.startDate || new Date().toISOString().split('T')[0],
        deadline: taskData.deadline,
      });
      showNotification('Task created successfully', 'success');
    } catch (error) {
      showNotification('Failed to create task', 'error');
      console.error('Failed to create task:', error);
    }
  }, [createTask, showNotification]);

  const handleTaskEdit = useCallback(async (task: TaskListItem) => {
    try {
      await updateTask({
        id: task.id,
        data: {
          title: task.name,
          description: task.description,
          status: task.status,
          priority: task.priority,
          startDate: task.startDate,
          deadline: task.deadline,
        }
      });
      showNotification(`Task "${task.name}" updated successfully`, 'success');
    } catch (error) {
      showNotification('Failed to update task', 'error');
      console.error('Failed to update task:', error);
    }
  }, [updateTask, showNotification]);

  const handleTaskDelete = useCallback(async (taskId: string) => {
    try {
      await deleteTask(taskId);
      showNotification('Task deleted successfully', 'success');
      // Close panel if deleting current task
      if (selectedTaskId === taskId) {
        setIsPanelOpen(false);
        setSelectedTaskId(null);
      }
    } catch (error) {
      showNotification('Failed to delete task', 'error');
      console.error('Failed to delete task:', error);
    }
  }, [deleteTask, showNotification, selectedTaskId]);

  // Clean task status change with optimistic updates
  const handleTaskStatusChange = useCallback(async (taskId: string, status: string) => {
    console.log('üéØ Clean handleTaskStatusChange called:', { taskId, status });
    
    try {
      await updateStatus(taskId, status);
      showNotification(`Task status updated to ${status}`, 'success');
      console.log('üéâ Task status update completed successfully');
    } catch (error) {
      showNotification('Failed to update task status', 'error');
      console.error('‚ùå Failed to update task status:', error);
    }
  }, [updateStatus, showNotification]);

  const handleTaskAssign = useCallback(async (taskId: string, assigneeData: {
    id: string;
    name: string;
    email: string;
  }) => {
    try {
      await updateTask({
        id: taskId,
        data: {
          assignedToIds: [assigneeData.id],
        }
      });
      showNotification(`Task assigned to ${assigneeData.name}`, 'success');
    } catch (error) {
      showNotification('Failed to assign task', 'error');
      console.error('Failed to assign task:', error);
    }
  }, [updateTask, showNotification]);

  const handleBulkAction = useCallback(async (taskIds: string[], action: 'delete' | 'complete' | 'archive') => {
    try {
      switch (action) {
        case 'delete':
          await Promise.all(taskIds.map(id => deleteTask(id)));
          showNotification(`${taskIds.length} tasks deleted`, 'success');
          break;
        case 'complete':
          // Use clean SWR pattern for bulk status updates
          await Promise.all(taskIds.map(id => updateStatus(id, 'completed')));
          showNotification(`${taskIds.length} tasks completed`, 'success');
          break;
        case 'archive':
          // Add archive logic if needed
          showNotification(`${taskIds.length} tasks archived`, 'success');
          break;
      }
    } catch (error) {
      showNotification(`Failed to ${action} tasks`, 'error');
      console.error(`Failed to ${action} tasks:`, error);
    }
  }, [deleteTask, updateStatus, showNotification]);

  // Handle task move between buckets - No manual revalidation needed
  const handleTaskMove = useCallback(async (taskId: string, bucketId: string) => {
    try {
      await moveTaskToActionTime(taskId, bucketId as TaskActionTime);
      showNotification(`Task moved to ${bucketId.replace('-', ' ')}`, 'success');
      // ‚úÖ No manual revalidate() - optimistic updates handle this automatically
    } catch (error) {
      showNotification('Failed to move task', 'error');
      console.error('Failed to move task:', error);
    }
  }, [moveTaskToActionTime, showNotification]);

  // Convert tasks to TaskListItem format - Clean and simple
  const taskListItems = useMemo(() => {
    if (!tasks || !Array.isArray(tasks)) return [];
    const mappedTasks = tasks.map(task => {
      const mappedTask = {
        id: task.id.toString(),
        name: task.title,
        description: task.description,
        assignees: task.creatorName ? [{
          id: 'creator',
          name: task.creatorName,
          avatar: task.creatorName.split(' ').map(n => n[0]).join('').toUpperCase()
        }] : [],
        dueDate: task.dueDate !== 'No due date' ? task.dueDate : undefined,
        startDate: task.startDate ? task.startDate.toISOString().split('T')[0] : undefined,
        endDate: task.endDate ? task.endDate.toISOString().split('T')[0] : undefined,
        deadline: task.dueDateISO ? task.dueDateISO.toISOString().split('T')[0] : (task.dueDate !== 'No due date' ? task.dueDate : undefined),
        priority: task.priority,
        status: task.status,
        completed: task.completed || task.status === 'completed' || task.status === 'DONE',
        tags: task.tags || [],
        project: task.tagText || undefined,
        createdAt: task.createdAt ? task.createdAt.toISOString() : new Date().toISOString(),
        updatedAt: task.updatedAt ? task.updatedAt.toISOString() : new Date().toISOString(),
      };
      
      // Debug logging for date fields
      console.log('üîç Task date mapping:', {
        taskId: task.id,
        taskTitle: task.title,
        originalDueDate: task.dueDate,
        originalDueDateISO: task.dueDateISO,
        originalStartDate: task.startDate,
        originalEndDate: task.endDate,
        mappedDueDate: mappedTask.dueDate,
        mappedDeadline: mappedTask.deadline,
        mappedStartDate: mappedTask.startDate,
        mappedEndDate: mappedTask.endDate
      });
      
      return mappedTask;
    });
    
    console.log('üìã Total mapped tasks:', mappedTasks.length);
    return mappedTasks;
  }, [tasks]);

  // Business Logic: Bucket configuration for My Tasks page
  const getBucketInfo = useCallback((bucketId: string, taskCount: number) => {
    const bucketConfigs = {
      'recently-assigned': { 
        title: 'Recently assigned', 
        description: `M·ªõi ƒë∆∞·ª£c giao (${taskCount})`,
        color: '#6B7280' 
      },
      'do-today': { 
        title: 'Do today', 
        description: `L√†m h√¥m nay (${taskCount})`,
        color: '#DC2626' 
      },
      'do-next-week': { 
        title: 'Do next week', 
        description: `L√†m tu·∫ßn sau (${taskCount})`,
        color: '#F59E0B' 
      },
      'do-later': { 
        title: 'Do later', 
        description: `ƒê·ªÉ sau (${taskCount})`,
        color: '#10B981' 
      },
    };
    return bucketConfigs[bucketId as keyof typeof bucketConfigs] || bucketConfigs['do-later'];
  }, []);

  // Business Logic: Task grouping by status for My Tasks page
  const taskBuckets = useMemo((): TaskBucket[] => {
    const bucketMap = new Map<string, TaskListItem[]>();
    
    // Initialize buckets
    ['recently-assigned', 'do-today', 'do-next-week', 'do-later'].forEach(bucket => {
      bucketMap.set(bucket, []);
    });

    // Group tasks by status (business logic specific to My Tasks)
    taskListItems.forEach(task => {
      let bucketId = 'do-later'; // default
      
      if (task.status === 'TODO' || task.status === 'todo') {
        bucketId = 'do-today';
      } else if (task.status === 'IN_PROGRESS' || task.status === 'in-progress') {
        bucketId = 'do-today';
      } else if (task.status === 'DONE' || task.status === 'completed') {
        bucketId = 'do-later';
      }
      
      const bucketTasks = bucketMap.get(bucketId) || [];
      bucketTasks.push(task);
      bucketMap.set(bucketId, bucketTasks);
    });

    // Create buckets with business logic
    return [
      'recently-assigned',
      'do-today', 
      'do-next-week',
      'do-later'
    ].map(bucketId => {
      const bucketTasks = bucketMap.get(bucketId) || [];
      const bucketInfo = getBucketInfo(bucketId, bucketTasks.length);
      
      return {
        id: bucketId,
        title: bucketInfo.title,
        description: bucketInfo.description,
        color: bucketInfo.color,
        tasks: bucketTasks,
      };
    });
  }, [taskListItems, getBucketInfo]);

  // Get selected task for detail panel
  const selectedTask = useMemo(() => {
    if (!selectedTaskId) return null;
    return taskListItems.find(task => task.id === selectedTaskId) || null;
  }, [selectedTaskId, taskListItems]);

  // Task detail panel handlers
  const handleTaskSave = useCallback(async (taskId: string, updates: Partial<TaskListItem>) => {
    try {
      await updateTask({
        id: taskId,
        data: {
          title: updates.name,
          description: updates.description,
          status: updates.status,
          priority: updates.priority,
          startDate: updates.startDate,
          deadline: updates.deadline,
        }
      });
      showNotification('Task saved successfully', 'success');
      setIsPanelOpen(false);
      setSelectedTaskId(null);
    } catch (error) {
      showNotification('Failed to save task', 'error');
      console.error('Failed to save task:', error);
    }
  }, [updateTask, showNotification]);

  const handleClosePanel = useCallback(() => {
    setIsPanelOpen(false);
    setSelectedTaskId(null);
  }, []);

  // Enhanced search handler
  const handleSearchChange = useCallback((value: string) => {
    setSearchInput(value);
  }, []);

  // Apply search filter to tasks
  const filteredTasks = useMemo(() => {
    if (!taskListItems || !Array.isArray(taskListItems)) return [];
    if (!searchInput.trim()) return taskListItems;
    
    const searchLower = searchInput.toLowerCase();
    return taskListItems.filter(task => 
      task.name?.toLowerCase().includes(searchLower) ||
      task.description?.toLowerCase().includes(searchLower)
    );
  }, [taskListItems, searchInput]);

  // Task management object - Clean and simple
  const taskManagement = useMemo(() => ({
    tasks: taskListItems,
    buckets: taskBuckets,
    filteredTasks,
    isLoading,
    isUpdating: isUpdating || isCreating || isDeleting || isStatusUpdating,
    isDeleting,
    error: error?.message || null,
    selectedTask,
    isPanelOpen,
    closeTaskPanel: handleClosePanel,
    stats: {
      total: taskListItems.length,
      completed: taskListItems.filter(t => t.completed || t.status === 'DONE' || t.status === 'completed').length,
      inProgress: taskListItems.filter(t => t.status === 'IN_PROGRESS' || t.status === 'in-progress').length,
      todo: taskListItems.filter(t => t.status === 'TODO' || t.status === 'todo' || t.status === 'pending').length,
    }
  }), [
    taskListItems,
    taskBuckets,
    filteredTasks,
    isLoading,
    isUpdating,
    isCreating,
    isDeleting,
    isStatusUpdating,
    error,
    selectedTask,
    isPanelOpen,
    handleClosePanel
  ]);

  // Enhanced task actions object - Pass specific handlers instead of generic actions
  const taskActions = useMemo(() => ({
    onTaskClick: handleTaskClick,
    onTaskEdit: handleTaskEdit,
    onCreateTask: handleTaskCreate,
    onTaskDelete: handleTaskDelete,
    onTaskStatusChange: handleTaskStatusChange,
    onTaskAssign: handleTaskAssign,
    onBulkAction: handleBulkAction,
  }), [
    handleTaskClick,
    handleTaskEdit,
    handleTaskCreate,
    handleTaskDelete,
    handleTaskStatusChange,
    handleTaskAssign,
    handleBulkAction,
  ]);

  // Loading state with better UX
  if (taskManagement.isLoading) {
    return (
      <div className="flex flex-col items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mb-4"></div>
        <div className="text-gray-600 text-lg">Loading your tasks...</div>
        <div className="text-gray-400 text-sm mt-2">Please wait a moment</div>
      </div>
    );
  }

  // Error state with retry option
  if (taskManagement.error) {
    return (
      <div className="flex flex-col items-center justify-center h-64">
        <div className="text-6xl mb-4">‚ö†Ô∏è</div>
        <div className="text-red-600 text-lg font-medium mb-2">
          Failed to load tasks
        </div>
        <div className="text-gray-500 text-sm mb-4">
          {taskManagement.error}
        </div>
        <button
          onClick={() => revalidate()}
          className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
        >
          Try Again
        </button>
      </div>
    );
  }

  return (
    <>
      <div className="space-y-6">
        {/* Main Task List - Clean separation of concerns */}
        <BucketTaskList
          buckets={taskManagement.buckets}
          loading={taskManagement.isLoading}
          error={taskManagement.error ?? undefined}
          searchValue={searchInput}
          onSearchChange={handleSearchChange}
          onTaskClick={handleTaskClick}
          onTaskCreate={handleTaskCreate}
          onTaskEdit={handleTaskEdit}
          onTaskDelete={handleTaskDelete}
          onTaskStatusChange={handleTaskStatusChange}

          onTaskAssign={handleTaskAssign}
          onBulkAction={handleBulkAction}
        />
      </div>

      {/* Enhanced Task Detail Panel */}
      {taskManagement.isPanelOpen && taskManagement.selectedTask && (
        <TaskDetailPanel
          task={taskManagement.selectedTask}
          isOpen={taskManagement.isPanelOpen}
          onClose={taskManagement.closeTaskPanel}
          onSave={handleTaskSave}
          onDelete={(taskId: string) => handleTaskDelete(taskId)}
          onStatusChange={handleTaskStatusChange}
        />
      )}
    </>
  );
};

export default MyTaskListPage;
